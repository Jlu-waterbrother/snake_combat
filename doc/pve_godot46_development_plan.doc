《蛇蛇大作战》PVE（Godot 4.6 Flatpak）完整开发流程计划

一、项目目标与边界
1) 目标
- 复刻“蛇蛇大作战”核心体验：移动、吃豆、成长、追击、碰撞死亡、击杀收益。
- 首期优先实现 PVE：单机玩家 + AI 敌蛇，不做联网对战。
- 支持桌面操作优先，移动端虚拟摇杆与加速按钮作为第二优先级并提前预留。

2) 首期范围（In Scope）
- 玩家蛇完整循环：移动 -> 吃食物 -> 增长 -> 得分 -> 碰撞死亡 -> 重生或结算。
- AI 敌蛇：巡航、觅食、规避、追击、加速。
- HUD：分数、长度、击杀数、状态提示。
- 相机与手感：平滑跟随、速度变化的可读反馈。
- 性能底线：高实体数量下保持稳定帧节奏。

3) 暂不包含（Out of Scope）
- 实时联网、账号系统、排行榜服务端、皮肤商城。
- 复杂赛季系统与社交系统。

4) 验收成功标准
- 核心 5 分钟循环可持续运行，玩法节奏稳定。
- AI 能形成有效对抗，且难度具备可配置梯度。
- 大量食物/蛇段场景下无明显卡顿尖峰。


二、技术基线与工程规范
1) 引擎与运行
- 使用本机 Flatpak 安装的 Godot 4.6。
- 建议启动方式：flatpak run org.godotengine.Godot。

2) 代码规范（GDScript）
- 全面采用 typed GDScript（导出变量、局部变量、函数签名显式类型）。
- 游戏仿真逻辑放在 _physics_process(delta)，避免帧率耦合。
- 系统之间通过 signal 解耦，避免深层 NodePath 硬耦合。
- 一脚本一职责：移动、AI、食物管理、UI 更新分离。

3) 场景架构（推荐）
- Main（组合根）
  - World（仿真层）
    - SnakeManager（玩家/敌蛇的生成与回收）
    - FoodManager（食物生成、对象池、回收）
    - CameraRig（镜头逻辑）
  - HUD（只读展示层）
- 可选 Autoload：GameState（局级状态、难度参数、得分聚合）。

4) 关键信号约定
- food_eaten(snake_id, amount)
- score_changed(snake_id, score)
- snake_died(snake_id, reason)
- snake_spawned(snake_id)
- match_state_changed(state)


三、目录与资源组织
1) 目录建议
- scenes/
  - main/
  - world/
  - snake/
  - food/
  - ui/
- scripts/
  - core/
  - managers/
  - ai/
  - ui/
- resources/
  - config/
  - curves/
- art/
- audio/

2) 配置数据化
- 使用 Resource/Config 保存可调参数（速度、转向率、成长倍率、AI 视野、刷新密度）。
- 尽量避免硬编码，把平衡参数留给配置层。


四、完整开发流程（按阶段推进）
阶段 0：需求冻结与玩法基线
- 输出：PVE 玩法说明、输入方案、胜负条件、首期范围清单。
- 完成标准：团队对“首版必须做/不做”有唯一定义。

阶段 1：工程初始化与最小骨架
- 创建 Godot 4.6 项目，设置输入映射（转向、加速、暂停）。
- 搭建 Main/World/SnakeManager/FoodManager/HUD 空骨架与信号总线。
- 建立基础配置资源（移动参数、食物参数、AI 参数）。
- 完成标准：场景可运行、模块可通信、配置可加载。

阶段 2：玩家蛇移动与身体系统
- 实现头部运动学：速度、加速、转向率限制。
- 实现身体段跟随（缓存轨迹点或段位置插值）。
- 实现摄像机跟随与基础阻尼。
- 完成标准：玩家蛇移动手感稳定，转向连续且可控。

阶段 3：食物系统与成长得分
- FoodManager 完成安全位置生成（避免贴脸出生）。
- 引入对象池，避免频繁实例化/销毁。
- 实现吃食物后成长与分数变化，统一单一真值源（score/length 同源）。
- 完成标准：吃食物 -> 分数/长度增长链路稳定。

阶段 4：碰撞与死亡循环
- 实现碰撞规则：撞墙（如有边界）、撞敌蛇身体、撞自己（按设计启用）。
- 触发 snake_died，执行死亡反馈与结算。
- 推荐实现“死亡掉落食物”（蛇体质量转化为可拾取资源）。
- 完成标准：死亡判定准确、反馈清晰、循环可继续。

阶段 5：PVE AI 敌蛇（首版）
- 行为状态机：巡航 -> 觅食 -> 追击 -> 规避。
- 感知逻辑：最近食物、邻近威胁、可击杀机会评估。
- 运动控制：与玩家同一运动规则（同转向/速度约束）。
- 完成标准：敌蛇能稳定生存并与玩家形成有效博弈。

阶段 6：难度系统与局内节奏
- 难度参数化：敌蛇数量、刷新率、侵略性、加速频率。
- 设计动态难度曲线（按玩家长度/分数调整）。
- 处理重生或单局结束流程，确保循环节奏连贯。
- 完成标准：新手可上手，进阶有挑战，难度可配置。

阶段 7：UI/交互/反馈完善
- HUD 展示分数、长度、击杀、状态消息。
- 加入击杀提示、受击反馈、增长反馈（音效/动画/屏幕提示）。
- 移动端预留虚拟摇杆 + Boost 按钮，避开 HUD 关键区。
- 完成标准：信息可读、反馈及时、不遮挡核心操作。

阶段 8：性能优化（重点）
- 全面使用对象池管理食物与蛇段，减少节点抖动。
- 合并高频计算，复用缓冲数组，减少每帧分配。
- 使用 Godot Profiler 做“优化前/后”对比记录。
- 完成标准：高实体场景帧时间稳定，无明显尖峰。

阶段 9：测试、打包与发布准备
- 功能回归：移动、成长、死亡、AI、UI、重生流程。
- 性能回归：低/中/高实体密度压测。
- 导出配置检查（桌面优先，后续扩展移动端）。
- 完成标准：可交付试玩包，且已附已知问题清单。


五、测试与验收清单（建议每阶段执行）
1) 功能正确性
- 玩家蛇是否在固定物理节拍下行为一致。
- 食物是否只在合法区域生成，回收后可复用。
- 计分、长度、速度倍率是否来自同一数据源。
- 死亡是否总能触发正确状态迁移。

2) 对抗体验
- AI 不应频繁自杀或卡死。
- AI 在不同难度下行为差异可感知。
- 玩家有明确的可反制空间（走位、加速、诱导）。

3) 性能稳定性
- 增加实体数量后，输入延迟不出现明显突变。
- 场景长期运行无内存持续增长异常。


六、风险与应对
1) 风险：蛇段数量增长导致性能抖动
- 应对：对象池 + 路径采样降频 + 分层更新策略。

2) 风险：AI 逻辑复杂导致不可预测
- 应对：先状态机后策略迭代，参数外置并可视化调参。

3) 风险：玩法节奏失衡（前期无聊/后期过难）
- 应对：建立可配置难度曲线，持续小步调参。


七、建议的执行顺序（可直接落地）
1. 搭项目骨架与信号。
2. 先做玩家蛇移动与手感。
3. 接食物-成长-得分闭环。
4. 接碰撞-死亡-掉落闭环。
5. 接入 AI 敌蛇并做基础博弈。
6. 完成 HUD 与反馈。
7. 做性能优化与回归测试。
8. 打包试玩并记录下一迭代。


八、首版交付定义（PVE）
- 可开始一局并控制蛇移动。
- 可通过吃食物持续成长并累计分数。
- 可与多条 AI 敌蛇进行对抗。
- 可在死亡后完成结算并重新开始。
- 在高密度场景下仍保持可玩与稳定。

（完）